/*
Чек-лист: 
v   в программном коде должны быть отступы;
v   имена функций и переменных должны отражать своё назначение;
v   избегать использования глобальных переменных;
v   переменные должны иметь подходящий тип с учётом знака и наименьшего размера; 
v   неиспользуемые переменные должны быть удалены;
v   лишние операторные скобки(пары «{}») также должны быть удалены;
v   входные параметры функций должны быть объявлены как константы(спецификатор «const»);
v   в качестве библиотеки ввода - вывода необходимо использовать потоковую библиотеку ввода - вывода «iostream»;
v   по результатам компиляции код не должен содержать ни одной ошибки и предупреждения;
v   весь ввод - вывод должен происходить внутри функции «main»;
x   программа должна осуществлять проверку значений входных данных как в функции main, так и в функциях, решающие задачу;
v   сообщения об ошибках должны выводиться в поток ошибок cerr;
-   для явных преобразований необходимо использовать преобразования в стиле C++; (что это такое?)
x   комментарии программы должны отражать псевдокод.
*/

//подключаем библиотеку iostream
#include <iostream>
using namespace std;

void matrix_fill(
    short int ** const matrix,
    const short int width, 
    const short int height, 
    const short int rand_max, 
    const short int rand_min
)
//функция заполнения массива
//тип void потому что мы работаем с памятью через указатель, соответственно в функции отсутсвует return, так как возврат получаем через указатель

{
    //srand() используется в связку с rand(). srand() нужен чтобы rand() каждый раз выдавал новые значения
    //[ПСЕВДОКОД:] Установить нулевую точку для последовательности, генерирумой функцией rand()
    srand(time(0));
    short int i, j;
    
    //[ПСЕВДОКОД:] Цикл, в ходе которого перебирается каждый элемент матрицы по вертикали
    for (i = 0; i < height; i++)
        //[ПСЕВДОКОД:] Вложенный цикл, в ходе которого перебирается каждый элемент матрицы по горизонтали
        for (j = 0; j < width; j++)
        {
            //[ПСЕВДОКОД:] определить с помощью случайного генератора число от 0 до 1 включительно, которjt означает положительное или отрицательное будет число ячейки матрицы
            short int rand_factor = rand() % 2;

            //[ПСЕВДОКОД:] Если случайно сгенерированное число == 0, то заполнить ячейку матрицы случайным ПОЛОЖИТЕЛЬНЫМ значением в диапазоне указанном пользователем для положительных значений
            if (rand_factor == 0)
                matrix[i][j] = rand() % (rand_max +1);
            //[ПСЕВДОКОД:] Иначе заполнить ячейку матрицы случайным ОТРИЦАТЕЛЬНЫМ значением в диапазоне, указанном пользователем для отрицательных значений
            else
                //abs функция модуля числа
                matrix[i][j] = -1 * (rand() % abs((rand_min - 1)));
        }
}

void matrix_sort(
    short int ** const matrix,
    const short int width, 
    const short int height, 
    short int* matrix_count
) {
    //функция сортировки массива
    //Упорядочить строки матрицы по возрастанию количества одинаковых элементов в каждой строке.

        //объявляем переменные
    short int i, j, j2;
    short int value_of_minimum_cell_of_matrix_count, position_of_minimum_cell;
    short int temp_A, temp_B;

    //[ПСЕВДОКОД:] Цикл, в ходе которого перебирается каждый элемент матрицы по вертикали
    for (i = 0; i < height; ++i)
    {
        //[ПСЕВДОКОД:] приравниваем переменной value_of_minimum_cell_of_matrix_count значение текущей ячейки в матрице-веторе matrix_count. 
        //matrix_count хранит кол-во повторяющихся значений в каждой строке
        value_of_minimum_cell_of_matrix_count = matrix_count[i];
        //[ПСЕВДОКОД:] создаём переменную position_of_minimum_cell, которая равна номеру текущей строки в анализируемой матрице matrix. В дальнейшщем в данную переменную будет записан номер позиции ячейки с минимальным значением, которая (ячейка) будет найдена в ходе работы цикла
        position_of_minimum_cell = i;

        //[ПСЕВДОКОД:] цикл сортировки массива matrix_count по возрастанию. цикл, который проходит по вектору matrix_count начиная с ячейки j == (i+1)  И ищет самую маленькую по значению ячейку.
        for (j = i + 1; j < height; j++)

            //[ПСЕВДОКОД:] Если значение текущей перебираемой ячейки менее, чем предыдущее зафиксированное перебираемое значение, зафиксированное в переменной value_of_minimum_cell_of_matrix_count
            if (matrix_count[j] < value_of_minimum_cell_of_matrix_count)
            {
                //[ПСЕВДОКОД:] то записать в переменную value_of_minimum_cell_of_matrix_count значение текущей перебираемой ячейки и в переменную position_of_minimum_cell зафикисровать номер позиции этой ячейки
                value_of_minimum_cell_of_matrix_count = matrix_count[j];
                position_of_minimum_cell = j;
            }

        //[ПСЕВДОКОД:] осуществляем перестановку строк (элементов) вектора-счётчика matrix_count ИЗ текущей ячеки [i] в минимальную (matrix_count[value_of_minimum_cell_of_matrix_count]) и из минимальной в текущую.
        //[ПСЕВДОКОД:] перестановка 1: присваиваем текущее значение ячейки вектора matrix_count временной переменой
        temp_B = matrix_count[i];

        //[ПСЕВДОКОД:] Пеерстановка 2: присваиваем значение минимальной переменной (найденное ранее) из переменной value_of_minimum_cell_of_matrix_count текущей позиции в векторе matrix_count
        matrix_count[i] = value_of_minimum_cell_of_matrix_count;

        //Перестановка 3: присваиваем значение из временной перменной
        matrix_count[position_of_minimum_cell] = temp_B;


        //выполяем аналогичную операцию по перестановке 
        for (j2 = 0; j2 < width; j2++)
        {
            temp_A = matrix[i][j2];
            matrix[i][j2] = matrix[position_of_minimum_cell][j2];
            matrix[position_of_minimum_cell][j2] = temp_A;
        }
    }
}

short int matrix_first_positive_column(
    short int ** const matrix,
    const short int width, 
    const short int height
)
//Найти номер первого из столбцов, не содержащих ни одного отрицательного элемента
{
    short int index = -1; //переменная, отвечающая за номер столбца, без отрицательных знаков, -1 -- отсутствие такого столбца
    short int i, j;
    bool flag = true;

    //[ПСЕВДОКОД:] цикл, перебирающий матрицу
    //[ПСЕВДОКОД:] по строкам
    for (
        i = 0, flag = true;
        i < width;
        ++i, flag = true
        )
    {
        //[ПСЕВДОКОД:] по столбцам
        for (j = 0; j < height; ++j)

            //[ПСЕВДОКОД:] если ЗНАЧЕНИЕ_ЯЧЕЙКИ(матрицы[столбец][строка]) < 0, то флаг = false, прервать цикл и перейти на следующий столбец
            if (matrix[j][i] < 0)
            {
                flag = false;
                break;
            }

        //[ПСЕВДОКОД:] если флаг = true, то прервать цикл, index = номеру столбца
        if (flag)
        {
            index = i;
            break;
        }
    }
    //[ПСЕВДОКОД:] возвратить значение переменной index, которая означает номер первого столбца, который не содержит ни единого отрицательного элемента
    return index;
}

void matrix_repeated_elements_count(
    short int ** const matrix,
    const short int width, 
    const short int height, 
    short int* matrix_count)
//данная функция считает число повторяющихся элементов в матрице внутри каждой строки
//функция ничего не возвращает через return, а записывает в массив через указатель matrix_count число повторяющихся элементов
{
    //объявление переменных внутри функции
    short int i, j, j2;
    short int max_value;

    //[ПСЕВДОКОД:] Создать матрицу счётчик matrix_repeted_elements, которая идентична по размере входной матрице и заполнить создаваемую матрицу нулями.
    //объявление матрицы для хранения количества повторяющихся элементов
    //матрица имеет размеры идентичные основной матрице (matrix)
    int** matrix_repeted_elements = new int* [height];

    //теперь через цикл производится заполнение массива указателей на массивы, которые хранят данные
    for (i = 0; i < height; i++)
        matrix_repeted_elements[i] = new int[width];

    //заполнение матрицы для хранения количества повторяющихся элементов нулями, это нужно для корректного использования оператора инкремента при подсчёте
    for (i = 0; i < height; i++)
        for (j = 0; j < width; j++)
            matrix_repeted_elements[i][j] = 0;

    //[ПСЕВДОКОД:] Цикл, в ходе которого анализируются поочерёдно все строки матрицы
    //посчитать число повторяющихся элементов в каждой строке
    for (i = 0; i < height; ++i)
    {
        //[ПСЕВДОКОД:] Создаётся переменная max_value, определяющая максимальную интенсивность повторения какой-либо ячейки в матрице. Данной переменной присваивается 0.
        max_value = 0;
        //[ПСЕВДОКОД:] вложенная группа циклов, задача которых анализирую построчно, а далее поячеично матрицу, определить повторяющиеся ячейки в строке и зафиксировать в матрице matrix_repeted_elements интенсивность повторения каждой ячеки - 1
        for (j = 0; j < width; j++)
            for (j2 = j + 1; j2 < width; j2++)
                if (matrix[i][j] == matrix[i][j2])
                    matrix_repeted_elements[i][j]++;

        //[ПСЕВДОКОД:] Цикл, анализирующий строку, сравнивающий текущее значение в матрице интенсивности повтрения matrix_repeted_elements со значение в переменной max_value. Если значение текущей ячейки больше, то переменная max_value принимает это значение
        for (j = 0; j < width; j++)
            if (matrix_repeted_elements[i][j] > max_value)
                max_value += matrix_repeted_elements[i][j];
        
        //[ПСЕВДОКОД:] в результате работы данного цикла, получаем матрицу-вектор matrix_count, в которой зафиксирована число повторений одинаковых элементов в каждой строке исходной матрицы + 1
        if (max_value == 0)
            matrix_count[i] = max_value;
        else
            matrix_count[i] = max_value + 1;
    }


    //[ПСЕВДОКОД:] Выполнить очистку памяти матрицы matrix_repeted_elements
    for (i = 0; i < height; i++)
    {
        delete[] matrix_repeted_elements[i];
    }
    //очистка памяти 2: удаляем указатели на строки
    delete[] matrix_repeted_elements;
}

void cin_rescue() 
//функция, очищающая cin в случае ошибочного ввода
{
    std::cin.clear(); // то возвращаем cin в 'обычный' режим работы
    std::cin.ignore(32767, '\n'); // и удаляем значения предыдущего ввода из входного буфера
}

short int main() {
    
    //объявление переменных:
    short int M_width;                                //целое число, ширина матрицы
    short int M_height;                               //целое число, высота матрицы
    short int M_rand_min;                             //целое число, минимальное значение для рандомизации заполнения матрицы
    short int M_rand_max;                             //целое число, максимальное значение для рандомизации заполнения матрицы
    short int type_of_matrix_fill;                    //целое число, выбор типа заполнения матрицы
    short int matrix_element;                         //целое число, элемент матрицы для ручного ввода
    short int i, j, k;                                //счётчики циклов
    
    //объявление константных перменных-лимитов
    const short int M_width_limit = 10;               //максимальная ширина входной матрицы
    const short int M_height_limit = 10;              //максимальная высота входной матрицы
    const short int M_rand_min_limit = -100;          //минимальный предел случайно генерации заполнения матрицы
    const short int M_rand_max_limit = 100;           //максимальный предел случайно генерации заполнения матрицы

    
    //вывести сообщение о необходимости ввода входящих данных построчно
    cout << "Please enter necessary data line by line: " << std::endl;
    //бесконечный цикл для ввода входящих данных, который прервётся в случае корректно введенных данных, а именно ширина матрици
    while (true)
    {
        //запросить ширину матрицы
        cout << "> matrix width (only plus and integer value, limit: " << M_width_limit << "): "; cin >> M_width;      

        // Размер масива должен быть положитлеьным
        if (M_width > 0 and M_width <= M_width_limit)
            //если всё введено верно, то прервать бесконечный цикл while
            break;

        // если предыдущее извлечение не выполнилось или произошло переполнение, аналог cin.fail()
        if (!cin) cin_rescue();
        cerr << "ERROR: Invalid matrix size (width)" << endl << endl;

    }
    //бесконечный цикл для ввода входящих данных, который прервётся в случае корректно введенных данных, а именно высота матрицы
    while (true)
    {
        //запросить высоту матрицы
        cout << "> matrix height (only plus and integer value, limit:  " << M_height_limit << "): "; cin >> M_height;
        //проверка введённых дане

        // Размер масива должен быть положитлеьным
        if (M_height > 0 and M_height <= M_height_limit)
            //прервать цикл, если ввод корректен
            break;
        
        // если предыдущее извлечение не выполнилось или произошло переполнение, аналог cin.fail()
        if (!cin) cin_rescue();
        cerr << "ERROR: Invalid matrix size (height)" << endl << endl;
        
    }
    //бесконечный цикл для ввода входящих данных, который прервётся в случае корректно введенных данных, а именно выбор типа заполнения матрицы
    while (true)
    {
        //Запросить у пользователя тип заполнения матрицы
        cout << "> select type of matrix fill ([1] == random fill; [2] == manual fill element by element): "; cin >> type_of_matrix_fill;
        //проверка введенного значения
        if (type_of_matrix_fill == 1 or type_of_matrix_fill == 2)
            //прервать цикл while
            break;
        // если предыдущее извлечение не выполнилось или произошло переполнение, аналог cin.fail(), то есть cin.fail() == !cin
        if (!cin) cin_rescue();
        cerr << "ERROR: please select correct type of matrix fill" << endl << endl;
    }
    //если тип заполнения матрицы указан как автоматический
    if (type_of_matrix_fill == 1)
    {
        //бесконечный цикл для ввода входящих данных, который прервётся в случае корректно введенных данных, а именно минимальное число для случайного заполнения
        while (true)
        {
            //Запросить у пользователя нижнюю отрицателую границу диапазона чилисел для генерации и последующего заполнения матрицы
            cout << "> minimum digital value of randomize range to fill matrix (only minus and integer value " << M_rand_min_limit << "): "; cin >> M_rand_min;
            // проверка минимального рандомного значения: должно быть отрицательным
            if (M_rand_min < 0 and M_rand_min >= M_rand_min_limit) {
                //прервать цикл, если ввод корректен
                break;            
            }
            // если предыдущее извлечение не выполнилось или произошло переполнение, аналог cin.fail(), то есть cin.fail() == !cin
            if (!cin) cin_rescue();
            cerr << "ERROR: Minimum random matrix fill value must be negative integer" << endl << endl;
        }
        //бесконечный цикл для ввода входящих данных, который прервётся в случае корректно введенных данных, а именно максимальное число для случайного заполнения
        while (true)
        {
            //Запросить у пользователя нижнюю отрицателую границу диапазона чилисел для генерации и последующего заполнения матрицы
            cout << "> maximum digital value of randomize range to fill matrix (only positive and integer value " << M_rand_max_limit << "): ";  cin >> M_rand_max;
            //проверка нижней границы для рандомизации
            if (M_rand_max > 0 and M_rand_max <= M_rand_max_limit) {
                break;
            }
            if (!cin) cin_rescue();
            cerr << "ERROR: Maximum random matrix fill value must be positive and integer" << endl << endl;

        }
    }  


    //создание главного динамического массива
    //Выделение памяти для динамический массив возможно только зная размеры массивы, поэтому объявление массива производится после ввода пользователем размера массива
    short int **matrix = new short int* [M_height];         //создаём массив указателей на указатели (**)
    
    //теперь через цикл производится заполнение массива указателей на массивы, которые хранят данные
    for (short int i = 0; i < M_height; i++)
        matrix[i] = new short int[M_width];
    
    //объявление нового динамического масссива для хранения максимального числа повторяющихзся элементов
    //выделение памяти для массива, размер массива должен соответствовать высоте исходной матрицы
    short int* matrix_count = new short int[M_height];
    
    //если тип заполнения матрицы автоматический, то заполнить матрицу функцией автозаполнением:
    if (type_of_matrix_fill == 1)
        //вызов функции заполнения массива рандомными данными
        //аргументы (параметры) функции: сам массив, ширину, высоту, минимальное значение для рандомизации, максимальное значения для рандомизации
        matrix_fill(matrix, M_width, M_height, M_rand_max, M_rand_min);

    //если тип заполнения матрицы ручной, то, заполнить вручную:
    if (type_of_matrix_fill == 2)
    {
        cout << "Manual matrix filling start\n" << "Please enter value (only integer) of elements:\n";
        //цикл, перебирающий матрицу по вертикали
        for (i = 0; i < M_height; i++)
            //цикл, перебирающий матрицу по горизонтали
            for (j = 0; j < M_width; j++)
                //бесконечный цикл для ввода каждого элемента матрицы
                while (true)
                {
                    cout << "MATRIX[" << i << "][" << j << "]:\t"; cin >> matrix_element;
                    //если !cin == 1, значит пользователь совершил ошибку ввода
                    if (!cin)
                    {
                        cin_rescue();
                        cerr << "ERROR: please enter correct matrix element, use only integer" << endl;
                    }
                    //иначе, пользователь ввёл корректный элемент матрицы, сохранить введённые данные в матрицу и прервать бесконечный цикл while
                    else
                    {
                        matrix[i][j] = matrix_element;
                        break;
                    }
                }
    }
    
    //вывод сгенерированного, не модифицированного массива на экран
    cout << "Generated matrix: " << endl;
    for (i = 0; i < M_height; i++)
    {
        for (j = 0; j < M_width; j++)
            cout << matrix[i][j] << "\t";
        //переход на новую строку массива
        cout << endl;
    }

    //вызов функции, которая подсчитывает число повторяющихся элементов в массиве в соответствии с ТЗ
    matrix_repeated_elements_count(matrix, M_width, M_height, matrix_count);


   //вывод матрицы с количество повторяющихся элементов
   // по условию задания ничего выводить тут нельзя
    cout << endl << "Matrix with repeted repeaated elements:\n";
    for (i = 0; i < M_height; i++)
    {
        //вывод строки данных данных самой матрицы
        for (j = 0; j < M_width; j++)
            cout << matrix[i][j] << "\t";

        //вывод элемента матрицы-вектора-счётчика повторяющихся элементов    
        cout << "\t\t" << matrix_count[i] << endl;

    }


    //вызов функции сортировки массива (наиболее существенная функция всей программы)
    matrix_sort(matrix, M_width, M_height, matrix_count);

    //Вывод на экран сортированного массива
    cout << endl << "Sortered matrix:" << endl;
    for (int i = 0; i < M_height; i++)
    {
        for (int j = 0; j < M_width; j++)
            cout << matrix[i][j] << "\t"; //вывод отсортированной матрицы
        cout << "\t\t" << matrix_count[i]; //вывод числа повторяющихся элементов в строке
        cout << endl;//переход на новую строку массива//переход на новую строку массива
    }



    //вызов функции, которая проверяет столбец на наличие не отрицательных элементов
    int positive_column = matrix_first_positive_column(matrix, M_width, M_height);
    
    //вывод на экран номера столбца  со всеми позитивными значениями
    if (positive_column < 0) 
        //если не найден
        std::cout << std::endl << "Positive column:\tnot found" << std::endl;
    else 
        //если найден
        std::cout << std::endl << "Positive column founded: number of column (count from zero):\t" << positive_column << endl;




    //В С++ отсутвует сборщик мусора, очистить массив самостоятельно после завершения работы с ним    
    //очистка массива matrix_count
    delete[] matrix_count;

    //очистка массива matrix
    //Очистка памяти 1: сначала удаляем строки
    for (int i = 0; i < M_height; i++)
    {
        delete[] matrix[i];
    }
    //очистка памяти 2: удаляем указатели на строки
    delete[] matrix;
    
}
